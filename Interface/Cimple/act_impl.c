//
// Autogenerated based on code by L. J. Feldstein
//

#include <stdio.h>
#include <gsl/gsl_matrix.h>
#include "cimple_controller.h"

void ACT_m1(current_state * now, discrete_dynamics * d_dyn, system_dynamics * s_dyn, cost_function * f_cost){
    int target_cell =1;
    printf("Computing control sequence to go from cell %d to cell m1...", (*now).current_cell);
    fflush(stdout);
    for(size_t i=0; i<d_dyn->time_horizon;i++) {
        size_t current_time_horizon = d_dyn->time_horizon - i;
        gsl_matrix *u = gsl_matrix_alloc(now->x->size, current_time_horizon);
        get_input(u, now, d_dyn, s_dyn, target_cell, f_cost, current_time_horizon);
        printf("Applying it...");
        fflush(stdout);
        gsl_vector *w = gsl_vector_alloc(s_dyn->E->size2);
        get_disturbance(w, 0, 0.1);
        apply_control(now->x, u, s_dyn->A, s_dyn->B, s_dyn->E, w, i);
        int new_cell_found = 0;
        for (int j = 0; j < d_dyn->regions[now->current_cell]->number_of_polytopes; j++) {
            if (polytope_check_state(d_dyn->regions[now->current_cell]->polytopes[j], now->x)) {
                new_cell_found = 1;
                break;
            }
        }
        if (!new_cell_found) {
            for (int j = 0; j < d_dyn->regions[target_cell]->number_of_polytopes; j++) {
                if (polytope_check_state(d_dyn->regions[target_cell]->polytopes[j], now->x)) {
                    new_cell_found = 1;
                    now->current_cell = target_cell;
                    break;
                }
            }
        }
        if (!new_cell_found) {
            for (int k = 0; k < d_dyn->number_of_regions; k++) {
                for (int j = 0; j < d_dyn->regions[k]->number_of_polytopes; j++) {
                    if (polytope_check_state(d_dyn->regions[k]->polytopes[j], now->x)) {
                        now->current_cell = k;
                        break;
                    }
                }
            }
        }
        printf("New state:");
        gsl_vector_print(now->x, "now->");
        printf("New Cell: %d", now->current_cell);

        fflush(stdout);
        // Clean up!
        gsl_matrix_free(u);

    }
}

void ACT_m0(current_state * now, discrete_dynamics * d_dyn, system_dynamics * s_dyn, cost_function * f_cost){
    int target_cell =0;
    printf("Computing control sequence to go from cell %d to cell m0...", (*now).current_cell);
    fflush(stdout);
    for(size_t i=0; i<d_dyn->time_horizon;i++) {
        size_t current_time_horizon = d_dyn->time_horizon - i;
        gsl_matrix *u = gsl_matrix_alloc(now->x->size, current_time_horizon);
        get_input(u, now, d_dyn, s_dyn, target_cell, f_cost, current_time_horizon);
        printf("Applying it...");
        fflush(stdout);
        gsl_vector *w = gsl_vector_alloc(s_dyn->E->size2);
        get_disturbance(w, 0, 0.1);
        apply_control(now->x, u, s_dyn->A, s_dyn->B, s_dyn->E, w, i);
        int new_cell_found = 0;
        for (int j = 0; j < d_dyn->regions[now->current_cell]->number_of_polytopes; j++) {
            if (polytope_check_state(d_dyn->regions[now->current_cell]->polytopes[j], now->x)) {
                new_cell_found = 1;
                break;
            }
        }
        if (!new_cell_found) {
            for (int j = 0; j < d_dyn->regions[target_cell]->number_of_polytopes; j++) {
                if (polytope_check_state(d_dyn->regions[target_cell]->polytopes[j], now->x)) {
                    new_cell_found = 1;
                    now->current_cell = target_cell;
                    break;
                }
            }
        }
        if (!new_cell_found) {
            for (int k = 0; k < d_dyn->number_of_regions; k++) {
                for (int j = 0; j < d_dyn->regions[k]->number_of_polytopes; j++) {
                    if (polytope_check_state(d_dyn->regions[k]->polytopes[j], now->x)) {
                        now->current_cell = k;
                        break;
                    }
                }
            }
        }
        printf("New state:");
        gsl_vector_print(now->x, "now->");
        printf("New Cell: %d", now->current_cell);

        fflush(stdout);
        // Clean up!
        gsl_matrix_free(u);

    }
}

void ACT_m2(current_state * now, discrete_dynamics * d_dyn, system_dynamics * s_dyn, cost_function * f_cost){
    int target_cell =2;
    printf("Computing control sequence to go from cell %d to cell m2...", (*now).current_cell);
    fflush(stdout);
    for(size_t i=0; i<d_dyn->time_horizon;i++) {
        size_t current_time_horizon = d_dyn->time_horizon - i;
        gsl_matrix *u = gsl_matrix_alloc(now->x->size, current_time_horizon);
        get_input(u, now, d_dyn, s_dyn, target_cell, f_cost, current_time_horizon);
        printf("Applying it...");
        fflush(stdout);
        gsl_vector *w = gsl_vector_alloc(s_dyn->E->size2);
        get_disturbance(w, 0, 0.1);
        apply_control(now->x, u, s_dyn->A, s_dyn->B, s_dyn->E, w, i);
        int new_cell_found = 0;
        for (int j = 0; j < d_dyn->regions[now->current_cell]->number_of_polytopes; j++) {
            if (polytope_check_state(d_dyn->regions[now->current_cell]->polytopes[j], now->x)) {
                new_cell_found = 1;
                break;
            }
        }
        if (!new_cell_found) {
            for (int j = 0; j < d_dyn->regions[target_cell]->number_of_polytopes; j++) {
                if (polytope_check_state(d_dyn->regions[target_cell]->polytopes[j], now->x)) {
                    new_cell_found = 1;
                    now->current_cell = target_cell;
                    break;
                }
            }
        }
        if (!new_cell_found) {
            for (int k = 0; k < d_dyn->number_of_regions; k++) {
                for (int j = 0; j < d_dyn->regions[k]->number_of_polytopes; j++) {
                    if (polytope_check_state(d_dyn->regions[k]->polytopes[j], now->x)) {
                        now->current_cell = k;
                        break;
                    }
                }
            }
        }
        printf("New state:");
        gsl_vector_print(now->x, "now->");
        printf("New Cell: %d", now->current_cell);

        fflush(stdout);
        // Clean up!
        gsl_matrix_free(u);
    }
}

void ACT_m3(current_state * now, discrete_dynamics * d_dyn, system_dynamics * s_dyn, cost_function * f_cost){
    int target_cell =3;
    printf("Computing control sequence to go from cell %d to cell m3...", (*now).current_cell);
    fflush(stdout);
    for(size_t i=0; i<d_dyn->time_horizon;i++) {
        size_t current_time_horizon = d_dyn->time_horizon - i;
        gsl_matrix *u = gsl_matrix_alloc(now->x->size, current_time_horizon);
        get_input(u, now, d_dyn, s_dyn, target_cell, f_cost, current_time_horizon);
        printf("Applying it...");
        fflush(stdout);
        gsl_vector *w = gsl_vector_alloc(s_dyn->E->size2);
        get_disturbance(w, 0, 0.1);
        apply_control(now->x, u, s_dyn->A, s_dyn->B, s_dyn->E, w, i);
        int new_cell_found = 0;
        for (int j = 0; j < d_dyn->regions[now->current_cell]->number_of_polytopes; j++) {
            if (polytope_check_state(d_dyn->regions[now->current_cell]->polytopes[j], now->x)){
                new_cell_found = 1;
                break;
            }
        }
        if(!new_cell_found){
            for (int j = 0; j < d_dyn->regions[target_cell]->number_of_polytopes; j++) {
                if (polytope_check_state(d_dyn->regions[target_cell]->polytopes[j], now->x)){
                    new_cell_found = 1;
                    now->current_cell=target_cell;
                    break;
                }
            }
        }
        if(!new_cell_found){
            for(int k=0; k<d_dyn->number_of_regions;k++){
                for (int j = 0; j < d_dyn->regions[k]->number_of_polytopes; j++) {
                    if (polytope_check_state(d_dyn->regions[k]->polytopes[j], now->x)){
                        now->current_cell=k;
                        break;
                    }
                }
            }
        }
        printf("New state:");
        gsl_vector_print(now->x, "now->");
        printf("New Cell: %d", now->current_cell);

        fflush(stdout);
        // Clean up!
        gsl_matrix_free(u);
    }
}

